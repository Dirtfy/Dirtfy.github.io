---
published: false
title: "[BOJ-C/C++] 20061 모노미노도미노 2 풀이"
last_modified_at: 2023-01-24
toc: true
toc_sticky: true
use_math: true
categories:
  - PS
tags:
  - BOJ
  - 구현
  - 시뮬레이션
  - 삼성 SW 역량 테스트 기출 문제
  - C/C++
---

## [백준 20061 모노미노도미노 2 문제 보러가기](https://www.acmicpc.net/problem/20061)

<br>

## 문제 요약

* 얻은 점수와 파란색 보드와 초록색 보드에서 타일이 들어있는 칸의 개수를 구하라
* 1초, 512MB

<br>

* 소년 상어는 (0, 0)에 있는 물고기를 먹고, (0, 0)에 들어가게 된다.<br>
상어의 방향은 (0, 0)에 있던 물고기의 방향과 같다. 이후 물고기가 이동한다.
* 방향 : $(1, 8) \to (↑, ↖, ←, ↙, ↓, ↘, →, ↗)$

* 이동 과정

1. 물고기가 이동한다.<br>
번호가 작은 물고기부터 한칸 이동한다.<br>
이동가능 : 빈 칸, 다른 물고기가 있는 칸<br>
이동불가능 : 상어가 있는칸, 격자를 넘는 칸<br>
45도씩 반시계 회전하며 칸을 확인한다.<br>
이동할 수 있는 칸이 없으면 이동을 하지 않는다.<br>
다른 물고기가 있는 칸으로 이동할 때는 서로의 위치를 바꾸는 방식으로 이동한다.
2. 상어가 이동한다.<br>
현재 방향으로 원하는 만큼 이동할수 있다.<br>
단, 물고기가 있는 칸으로 이동해야 한다.<br>
이동하는 칸에 물고기를 먹고 그 물고기의 방향을 가진다.<br>
이동하는 중에 지나가는 칸의 물고기는 먹지 않는다.<br>
상어가 이동할 수 있는 칸이 없으면 종료하고 아니면 1번으로 돌아간다.

<br>

* $((a_i, b_i))$

<br>

* $1 \leq a_i \leq 16$
* $1 \leq b_i \leq 8$

<br>

## 아이디어

0. 크기가 작아서 이동의 시간보다 경우의 수가 중요하겠네<br>
근데 그것도 크기가 작아서 믿음을 가지고 구현만 하면 될거 같기는 한데..<br>
1. 이동 한번 시간복잡도 $f(M)$($M$ 은 물고기 수)<br>
$= 1번 과정 + 2번 과정$<br>
$= 8M + 1 = 8M$<br>
2. 전체 시간복잡도 $O(N)$<br>
$= T \times f(M)$ ($T$ 는 경우의 수)<br>
$\approx (\displaystyle\prod_{i=15}^{1}{3\frac{i}{15}})
\times f(M)\leq 43\times120$<br>
$(\because$ 물고기가 한 칸에 있을 확률이 약 $\frac{i}{15}$ 이고<br>
상어가 선택할 수 있는 최대 칸 수가 3칸이기 때문에<br>
탐색의 깊이가 $15-i$ 일때 약 $3\frac{i}{15}$ 의 경우의 수가 있다.<br>
그리고 탐색은 최대 물고기의 수만큼 즉, 15만큼 깊어질 수 있다.$)$<br>
$= 6,450 \leq 1억$<br>
어디까지나 대략적 추측이긴 하다... 정확한 계산은 몰라~
3. 전체 공간복잡도는 맵과 탐색의 깊이에 따른다. 따라서 $O(16\times15)$<br>
물론 전역변수로 선언하여 절약할 수 있겠지만 그러면 원상복귀가 귀찮아서..

* 예상 시간복잡도 $O(T\times M) = ??$
* 예상 공간복잡도 $O(16\times15) = O(1)$

<br>

## 설계

### 함수

```cpp
###pseudo code###

Max

main(){

    map = in()

    DFS(shark, map)

    out(Max)
}

DFS(shark, map){
    eat(&shark, &map)

    for 1~16{
        for map{
            if map[now].num == i{
                moveFish(&map[now])
                break
            }
        }
    }

    while sharMove(&shark){
        DFS(&shark, &map)
    }

    if shark.sum > Max
        Max = shark.sum
}

eat(shark, map){
    shark.direc = map[now].direc
    shark.sum += map[now].num
    map[now] = 0
}
moveFish(map){
    for direc{
        if map[direc] == blank{
            map[direc] = map[now]
            return
        }
        else if map[direc] == fish{
            tmp = map[direc]
            map[direc] = map[now]
            map[now] = tmp
            return
        }
    }
}
moveShark(shark, map){
    do{
        shark = shark[next]

        if shark is out of map
            return false
        else if map[shark] == fish
            return true
    }while(shark is in map)
}

```

### 데이터

* Map 구조체(매개변수 복사를 위해), 상어 구조체, 정수
* 정수 : int<br>
(위치, 물고기 번호, 번호 합, 방향을 표현하기 위해 사용됨<br>
이때 번호 합이 가장 커질 수 있는데 최대 $136$ 이므로 int면 충분)

<br>

## 전체 코드

```cpp
#include<stdio.h>

#define SIZE_R 6
#define SIZE_C 4
#define MARGIN 1

#define FALSE 0
#define TRUE 1

typedef struct{
    int map[SIZE_R+MARGIN][SIZE_C+MARGIN];
    int score;

    void init(){
        for(int i = 0;i < SIZE_C;i++){
            map[SIZE_R][i] = TRUE;
        }
        score = 0;
    }
    void put(const int t, const int r, const int c){
        int pause;
        int result;

        switch(t){
            case 1:
                for(pause = -1;map[pause+1][c] != TRUE;pause++){ }
                map[pause][c] = TRUE;
                break;
            case 2:
                for(pause = -1;map[pause+1][c] != TRUE && map[pause+1][c+1] != TRUE;pause++){ }
                map[pause][c] = map[pause][c+1] = TRUE;
                break;
            case 3:
                for(pause = -2;map[pause+2][c] != TRUE;pause++){ }
                map[pause][c] = map[pause+1][c] = TRUE;
                break;
        }

        while((result = check()) > 0){
            if(result >= 2){
                score++;
                move(result);
            }
            else
                move(SIZE_R-1);
        }
    }
    int check(){
        int flag;
        for(int r = SIZE_R-1;r > 1;r--){
            flag = TRUE;
            for(int c = 0;c < SIZE_C;c++){
                if(map[r][c] == FALSE)
                    flag = FALSE;
            }
            if(flag)
                return r;
        }
        for(int c = 0;c < SIZE_C;c++){
            if(map[1][c] == TRUE)
                return 1;
        }
        return 0;
    }
    void move(const int removeRow){
        for(int c = 0;c < SIZE_C;c++){
            map[removeRow][c] = FALSE;
            for(int r = removeRow;r > 0;r--){
                map[r][c] = map[r-1][c];
            }
            map[0][c] = FALSE;
        }
    }
}Domino;

int N;
Domino Board[2];

int main(){
    int t, r, c;

    Board[0].init();
    Board[1].init();

    scanf("%d", &N);
    for(int i = 0;i < N;i++){
        scanf("%d %d %d", &t, &r, &c);

        switch(t){
            case 1:
                Board[0].put(1, r, c);
                Board[1].put(1, c, r);
                break;
            case 2:
                Board[0].put(2, r, c);
                Board[1].put(3, c, r);
                break;
            case 3:
                Board[0].put(3, r, c);
                Board[1].put(2, c, r);
                break;
        }
    }

    printf("%d\n", Board[0].score+Board[1].score);
    int cnt = 0;
    for(int r = 0;r < SIZE_R;r++){
        for(int c = 0;c < SIZE_C;c++){
            cnt += Board[0].map[r][c] + Board[1].map[r][c];
        }
    }
    printf("%d", cnt);

    return 0;
}
```

* 시간복잡도 $O(TM) = ??$
* 공간복잡도 $O(16\times15) = O(1)$

<br>

[제출코드](https://www.acmicpc.net/source/49875506)

<br>

> 크기가 매우 작아서 크게 고민없이 풀수 있었던 문제<br>
> 그냥 완전탐색으로 접근해도 괞찬다는것을 알고 구현만 할수 있으면 됐다.<br>
> 크기가 작아서 가지치기도 하지 않았고 구현을 위해 메모리도 희생했는데<br>
> 나중에 응용을 위해서는 최적화를 해볼 필요도 있겠다.
