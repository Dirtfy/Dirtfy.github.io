---
title: "[BOJ-C/C++] 11758 CCW 풀이"
last_modified_at: 2023-01-06
toc: true
toc_sticky: true
categories:
  - PS
tags:
  - BOJ
  - CCW
  - 기하학
  - C/C++
---

> 두 벡터간의 관계에 따라 외적 결과가 어떻게 변하는지 알고있으면 도움이 되는 문제였다.  
> 기하학 문제에서 기본이 되는 CCW알고리즘(?)이니 잘 기억해 두는게 좋겠다.

<br>
  
## [백준 11758 CCW 문제 보러가기](https://www.acmicpc.net/problem/11758)

<br>

## 문제 요약

* 세 점을 순서대로 이으면 시계방향인지 반시계방향인지 판별
* -10,000 ≤ x1, y1, x2, y2, x3, y3 ≤ 10,000
* 반시계방향이면 1, 시계방향이면 -1, 일직선이면 0 출력

<br>

## 풀이 계획

### 아이디어

1. 2차원 벡터를 외적했을때 z축 성분이 양수면 두 벡터가 시계방향이고 음수면 반시계방향이므로 방향을 판별할 수 있다.
2. 벡터는 평행이동하여도 동일하다.
3. 세 점을 순서대로 p1, p2, p3라 보면 p1, p2로 만들어지는 벡터를 v1, p2, p3로 만들어지는 벡터를 v2가 있다.

따라서 v1과 v2를 외적하면 세 점을 순서대로 이었을 때 방향을 판별할 수 있다.

### 구현

1. 데이터 타입

* 점 구조체, 벡터 구조체, 정수
* 정수 범위 : int ( -10,000<sup>2</sup> - 10,000<sup>2</sup>) ~ (10,000<sup>2</sup> + 10,000<sup>2</sup>) -> -2억 ~ 2억)

2. 함수

* 외적

<br>

## 전체 코드

```cpp
#include<stdio.h>

typedef struct{
    int x, y;
}Pos;

typedef struct{
    Pos p;
}Vector;

int cross(Vector v1, Vector v2);

int main(){
    Pos p1, p2, p3;
    Vector v1, v2;

    scanf("%d %d", &p1.x, &p1.y);
    scanf("%d %d", &p2.x, &p2.y);
    scanf("%d %d", &p3.x, &p3.y);

    v1.p.x = p2.x-p1.x;   v1.p.y = p2.y-p1.y;
    v2.p.x = p3.x-p1.x;   v2.p.y = p3.y-p1.y;

    printf("%d", cross(v1, v2));

    return 0;
}

int cross(Vector v1, Vector v2){
    int result = v1.p.x*v2.p.y - v1.p.y*v2.p.x;
    return result == 0 ? 0 : (result > 0 ? 1 : -1);
}
```
