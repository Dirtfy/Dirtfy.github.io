---
published: true
title: "[BOJ-C/C++] 17779 게리맨더링 2 풀이"
last_modified_at: 2023-01-28
toc: true
toc_sticky: true
use_math: true
categories:
  - PS
tags:
  - BOJ
  - 구현
  - 브루트포스 알고리즘
  - 시뮬레이션
  - 삼성 SW 역량 테스트 기출 문제
  - C/C++
---

## [백준 17779 게리맨더링 2 문제 보러가기](https://www.acmicpc.net/problem/17779)

<br>

## 문제 요약

* 선거구를 나누는 방법 중, 인구 $Min(Max($ 선거구 $) - $ $Min($ 선거구 $))$ 을 구하라
* 1초, 512MB

<br>

* 재현시는 크기가 N×N인 격자로 나타낼 수 있다.<br>
격자의 각 칸은 구역을 의미하고, r행 c열에 있는 구역은 (r, c)로 나타낼 수 있다.
* 구역을 다섯 개의 선거구로 나눠야 한다.
* 각 구역은 다섯 선거구 중 하나에 포함되어야 한다.
* 선거구는 구역을 적어도 하나 포함해야 한다.
* 한 선거구에 포함되어 있는 구역은 한 덩어리여야한다.

* 선거구를 나누는 방식<br>
선거구 색상<br>
![선거구 색상](){:width="300"}<br>
예시 1) $x = 2, y = 4, d_1 = 2, d_2 = 2$ <br>
![예시 1 x = 2, y = 4, d1 = 2, d2 = 2](){:width="400"}<br>
예시 2) $x = 2, y = 5, d_1 = 3, d_2 = 2$ <br>
![예시 2 x = 2, y = 5, d1 = 3, d2 = 2](){:width="400"}<br>

<br>

* $N$
* $(r, c)$

<br>

* $5 \leq N \leq 20$
* $1 \leq (r, c) \leq 100$

<br>

## 아이디어

0. 크기도 작아서 잘 구현하면 될듯?<br>
한번 회전 수행할때 말 개수 정도의 시간이 걸리고<br>
반복이 1,000번을 넘지 않으니까 시간은 충분하겠네
1. 전체 시간복잡도 $O(N)$<br>
$= T \times K \leq 1,000 \times 10 = 10,000 \leq 5,000만$
2. 전체 공간복잡도는 맵의 크기와 말의 개수에 따른다. 따라서 $O(N^2 + K)$<br>

* 예상 시간복잡도 $O(TK)$
* 예상 공간복잡도 $O(N^2 + K)$

<br>

## 설계

### 함수

```cpp
###pseudo code###

```

### 데이터

* 맵 2차원 배열, 말 구조체, 정수
* 정수 : int<br>
(위치, 반복 횟수, 말 번호를 표현하기 위해 사용됨<br>
이때 반복 횟수가 가장 커질 수 있는데 $1,000$ 이하 이므로)

<br>

## 전체 코드

```cpp
#include<stdio.h>

#define MAX_N 20
#define MAX_VALUE 100
#define MARGIN 1

typedef struct{
    int x, y;
    int d1, d2;
}Border;

int N;
int A[MAX_N+MARGIN][MAX_N+MARGIN];
Border B;
int Min = MAX_VALUE*MAX_N*MAX_N+MARGIN;

void bruteForce();

int main(){

    scanf("%d", &N);
    for(int i = 1;i <= N;i++){
        for(int j = 1;j <= N;j++){
            scanf("%d" , &(A[i][j]));
        }
    }

    bruteForce();

    printf("%d", Min);

    return 0;
}

int isIn(const int r, const int c){
    if(r-B.x >= -(c-B.y) && r-B.x >= c-B.y && 
        r-(B.x+B.d1) <= c-(B.y-B.d1) && r-(B.x+B.d2) <= -(c-(B.y+B.d2)))
        return 5;
    else if(1 <= r&&r < B.x+B.d1 && 1 <= c&&c <= B.y)
        return 1;
    else if(1 <= r&&r <= B.x+B.d2 && B.y < c&&c <= N)
        return 2;
    else if(B.x+B.d1 <= r&&r <= N && 1 <= c&&c < B.y-B.d1+B.d2)
        return 3;
    else
        return 4;
}
int calculate(){
    int sum[6] = { 0, };

    for(int r = 1;r <= N;r++){
        for(int c = 1;c <= N;c++){
            sum[isIn(r, c)] += A[r][c];  
        }
    }

    int min = sum[1], max = sum[1];
    for(int i = 2;i <= 5;i++){
        if(min > sum[i])
            min = sum[i];
        if(max < sum[i])
            max = sum[i];
    }

    return max-min;
}
void bruteForce(){
    int result;

    for(int x = 2;x <= N-1;x++){
        for(int y = 2;y <= N-1;y++){
            for(int d1 = 1;y-d1 >= 0;d1++){
                for(int d2 = 1;1 <= y-d1&&y+d2 <= N;d2++){
                    if(x+d1+d2 <= N && y-d1+d2 <= N){
                        B = {x, y, d1, d2};
                        result = calculate();
                        if(result < Min)
                            Min = result;
                    }
                }
            }
        }
    }
}
```

* 시간복잡도 $O(TKCN^2)$ : ($C$ 는 pile의 크기)<br>
같이 움직이는 말들을 구현하는데 드는 비용이 추가되었다.<br>
추가로 전체 맵을 돌면서 쌓인 개수를 확인해서 $N^2$ 도 추가 되었다.
* 공간복잡도 $O(N^2 \times C + M)$ : ($C$ 는 pile의 크기)<br>
마찬가지로 같이 움직이는 말들을 구현하기 위해 추가적인 공간을 할당했다.

<br>

[제출코드](https://www.acmicpc.net/source/49485272)

<br>

> 아쉬움이 좀 많이 남는 문제<br>
> 일단 처음 풀때 설계를 꼼꼼히 하지 않았던게 큰것같다.<br>
> 그래서 구현을 하며 예상하지 못했던 경우들을 만났었다.<br>
> 시간복잡도와 공간복잡도를 잘못 생각했다던가..<br>
> 이건 입력의 크기가 크지 않아서 큰 문제가 되지 않았지만 위험했다.<br>
> 그리고 전반적인 구현이 깔끔하지 못한듯하다.<br>
> 중복되는 코드들이 많고 줄일수 있는 코드도 보이고 비효율적인 부분도 있다.<br>
> 다시 한번 풀어볼 필요가 있겠다...
