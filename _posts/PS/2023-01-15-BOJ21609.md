---
published: false
title: "[BOJ-C/C++] 21609 상어 중학교 풀이"
last_modified_at: 2023-01-15
toc: true
toc_sticky: true
use_math: true
categories:
  - PS
tags:
  - BOJ
  - 구현
  - 그래프 이론
  - 그래프 탐색
  - 너비 우선 탐색
  - 시뮬레이션
  - 깊이 우선 탐색
  - 삼성 SW 역량 테스트 기출 문제
  - C/C++
---

## [백준 21609 상어 중학교 문제 보러가기](https://www.acmicpc.net/problem/21609)

<br>

## 문제 요약

<br>

## 아이디어

<br>

## 설계

### 함수

```cpp
```

### 데이터

<br>

## 전체 코드

```cpp
#include<stdio.h>

#define MAX_N 20
#define MAX_M 5
#define MARGIN 3

#define BLANK -2
#define BLACK -1
#define RAINBOW 0

#define FIND 0
#define REMOVE 1

#define FALSE 0
#define TRUE 1

typedef struct map{
    int data[MAX_N+MARGIN][MAX_N+MARGIN];
    int size;

    void init(int n){
        for(int i = 0;i <= n+1;i++){
            data[i][0] = data[i][n+1] = BLACK;
            data[0][i] = data[n+1][i] = BLACK;
        }
        size = n;
    }
    void move(int r, int c){
        int bottom;
        for(bottom = r;bottom > 0;bottom--){
            if(data[bottom][c] != BLACK && data[bottom][c] != BLANK)
                break;
        }

        int len = r-bottom;
        while(len-- > 0){
            for(int i = r;i > 0;i--){
                if(data[i-1][c] == BLACK){
                    data[i][c] = BLANK;
                    break;
                }
                data[i][c] = data[i-1][c];
            }
        }
    }
    void gravity(){
        for(int c = 1;c <= size;c++){
            for(int r = size;r > 1;r--){
                if(data[r][c] == BLANK)
                    move(r, c);
            }
        }
    }
    void rotate(){
        struct map tmp;

        tmp.init(size);
        for(int r = 1;r <= size;r++){
            for(int c = 1; c <= size;c++){
                tmp.data[size+1-c][r] = data[r][c];
            }
        }

        for(int r = 1;r <= size;r++){
            for(int c = 1; c <= size;c++){
                data[r][c] = tmp.data[r][c];
            }
        }
    }
}Map;
typedef struct pos{
    int r, c;

    int compare(struct pos p){
        if(r > p.r)
            return 1;
        else if(r < p.r)
            return -1;
        else{
            if(c > p.c)
                return 1;
            else if(c < p.c)
                return -1;
            else
                return 0;
        }
    }
}Pos;
typedef struct group{
    int size, rainbowCnt;
    Pos p;
    Pos color;

    int compare(struct group g){
        if(size > g.size)
            return 1;
        else if(size < g.size)
            return -1;
        else{
            if(rainbowCnt > g.rainbowCnt)
                return 1;
            else if(rainbowCnt < g.rainbowCnt)
                return -1;
            else
                return p.compare(g.p);
        }
    }
}Group;
typedef struct{
    Pos list[MAX_N*MAX_N+MARGIN];
    int head, tail;

    void init(){
        head = 0;   tail = -1;
    }
    void push(Pos p){
        list[++tail] = p;
    }
    Pos pop(){
        return list[head++];
    }
    int isEmpty(){
        return head <= tail ? FALSE : TRUE;
    }
}Queue;

int N, M;
Map Board;
Queue Q;
Group GroupList[MAX_N*MAX_N+MARGIN]; int GroupCnt;
int Score;

void findGroup();
void removeGroup(Group group);

int main(){
    Group maxGroup;

    scanf("%d %d", &N, &M);
    Board.init(N);
    for(int r = 1;r <= N;r++){
        for(int c = 1;c <= N;c++){
            scanf("%d", &(Board.data[r][c]));
        }
    }

    do{
        GroupCnt = 0;
        findGroup();

        if(GroupCnt > 0){
            maxGroup = GroupList[0];
            for(int i = 0;i < GroupCnt;i++){
                if(maxGroup.compare(GroupList[i]) < 0)
                    maxGroup = GroupList[i];
            }

            removeGroup(maxGroup);

            Board.gravity();
            Board.rotate();
            Board.gravity();
        }    
        
    }while(GroupCnt > 0);

    printf("%d", Score);

    return 0;
}

void countGroup(Pos start, int check[][MAX_N+MARGIN], const int mode){
    int move[5] = {0, -1, 0, 1, 0};
    Pos now = start, next;

    Q.init();
    Q.push(now);
    check[now.r][now.c] = TRUE;

    while(!Q.isEmpty()){
        now = Q.pop();

        for(int i = 0;i < 4;i++){
            next.r = now.r+move[i];
            next.c = now.c+move[i+1];

            if((1 <= next.r&&next.r <= N) && (1 <= next.c&&next.c <= N)){
                if(check[next.r][next.c] == FALSE){
                    if(Board.data[next.r][next.c] == Board.data[start.r][start.c] || Board.data[next.r][next.c] == RAINBOW){
                        Q.push(next);
                        check[next.r][next.c] = TRUE;
                    }
                }
            }
        }
    }

    for(int i = 0;i <= Q.tail;i++){
        if(Board.data[Q.list[i].r][Q.list[i].c] == RAINBOW){
            check[Q.list[i].r][Q.list[i].c] = FALSE;
        }
    }

    switch(mode){
        case FIND:
            if(Q.tail+1 >= 2){
                Pos standard = {N+1, N+1};
                Pos color;
                int rainbowCnt = 0;
                for(int i = 0;i <= Q.tail;i++){
                    if(Board.data[Q.list[i].r][Q.list[i].c] != RAINBOW && standard.compare(Q.list[i]) > 0)
                        standard = Q.list[i];
                    if(Board.data[Q.list[i].r][Q.list[i].c] == RAINBOW)
                        rainbowCnt++;
                    else
                        color = Q.list[i];
                }
                GroupList[GroupCnt++] = {Q.tail+1, rainbowCnt, standard, color};
            }
            break;
        case REMOVE:
            for(int i = 0;i <= Q.tail;i++){
                Board.data[Q.list[i].r][Q.list[i].c] = BLANK;
            }
            Score += (Q.tail+1)*(Q.tail+1);
            break;
    }
}
void findGroup(){
    int check[MAX_N+MARGIN][MAX_N+MARGIN] = { FALSE, };

    for(int r = 1;r <= N;r++){
        for(int c = 1;c <= N;c++){
            if(check[r][c] == FALSE)
                if(1 <= Board.data[r][c]&&Board.data[r][c] <= M)
                    countGroup({r, c}, check, FIND);
        }
    }
}
void removeGroup(Group group){
    int check[MAX_N+MARGIN][MAX_N+MARGIN] = { FALSE, };
    countGroup(group.color, check, REMOVE);
}
```

* 예상 시간복잡도 $O(MN^2)$
* 예상 공간복잡도 $O(N^2)$

<br>

[제출코드](https://www.acmicpc.net/source/49903901)

<br>

> 비교적 무난했던 문제<br>
> 헷갈릴 만한 부분은 물 양이 증가할때 동시에 일어난다 정도<br>
> 문제에서 강조를 해주지 않아서 깜빡할 수도 있겠다.<br>
> 그 외에는 이정도면 쉽다고 해도 될지도??
