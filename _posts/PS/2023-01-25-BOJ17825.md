---
published: false
title: "[BOJ-C/C++] 17825 주사위 윷놀이 풀이"
last_modified_at: 2023-01-25
toc: true
toc_sticky: true
use_math: true
categories:
  - PS
tags:
  - BOJ
  - 구현
  - 브루트포스 알고리즘
  - 시뮬레이션
  - 백트래킹
  - 삼성 SW 역량 테스트 기출 문제
  - C/C++
---

## [백준 17825 주사위 윷놀이 문제 보러가기](https://www.acmicpc.net/problem/17825)

<br>

## 문제 요약

* 얻은 점수와 파란색 보드와 초록색 보드에서 타일이 들어있는 칸의 개수를 구하라
* 1초, 512MB

<br>

* 보드<br>
![보드](https://github.com/Dirtfy/Dirtfy.github.io/blob/master/_posts/PS/R/2023-01-24-BOJ20061/%EB%B3%B4%EB%93%9C.png?raw=true){:width="450"}
* 블록의 종류<br>
![블록의 종류](https://github.com/Dirtfy/Dirtfy.github.io/blob/master/_posts/PS/R/2023-01-24-BOJ20061/%EB%B8%94%EB%A1%9D%EC%9D%98%20%EC%A2%85%EB%A5%98.png?raw=true){:width="300"}
* 블록의 이동 : 1x1 블록 예시<br>
![블록의 이동](https://github.com/Dirtfy/Dirtfy.github.io/blob/master/_posts/PS/R/2023-01-24-BOJ20061/%EB%B8%94%EB%A1%9D%EC%9D%98%20%EC%9D%B4%EB%8F%99.png?raw=true){:width="450"}

* 진행 과정

1. 블록을 놓는다.<br>
파란색 : 오른쪽으로 움직인다.<br>
초록색 : 아래쪽으로 움직인다.
2. 보드가 변한다.<br>
행(열)이 다 차면 끝의 블록이 사라지고 사라진 행(열)만큼 점수를 얻는다.<br>
만약, 연한 칸에 블록이 있다면 블록이 있는 행(열)만큼 끝의 블록이 사라진다.<br>
블록이 사라져 빈칸을 위(왼)쪽에서 움직여 채운다.

<br>

* $N$
* $(t, x ,y)$

<br>

* $1 \leq N \leq 10,000$
* $t = 1 \to 1×1\,(x, y)$<br>
$t = 2 \to 1×2\,(x, y), (x, y+1)$<br>
$t = 3 \to 2×1\,(x, y), (x+1, y)$

<br>

## 아이디어

0. 블록 한번의 이동이 대략 맵을 다 돌아보는 거라 볼수 있다.<br>
왜냐면 블록을 한칸씩 움직이며 확인 할 것이기 때문~<br>
그러면 $N \times 64$ 구현하자
1. 이동 한번 시간복잡도 $f(N)$<br>
$= 1번 과정 + 2번 과정$<br>
$= 2 + 2\times64 = 128$(초록, 파랑 각 한번씩)<br>
2. 전체 시간복잡도 $O(N)$<br>
$= N \times f(N) = 128N$<br>
$\leq 1,280,000 \leq 1억$
3. 전체 공간복잡도는 맵의 크기에 따른다. 따라서 $O(64)$<br>

* 예상 시간복잡도 $O(N)$
* 예상 공간복잡도 $O(64) = O(1)$

<br>

## 설계

### 함수

```cpp
###pseudo code###

Board[2][] //보드, 1이 초록, 2가 파랑

main(){

    N = in()
    while N-- > 0{
        t, x, y = in()
        
        Board[1].put(t, x, y)
        switch t {
            1 -> Board[2].put(1, y, x)
            2 -> Board[2].put(3, y, x)
            3 -> Board[2].put(2, y, x)
        }
    }

    cnt = 0
    score = Board[1].score + Board[2].score
    for Board[1], [2]{
        cnt += Board[1], [2] [now]
    }

    out(score, cnt)
}

put(t, x, y){
    while !(block touch the wall){
        move block
    }
    while(check()){
        plus score // score can be 1 or 2
        moveBlocks()
    }
}
```

### 데이터

* Board 구조체, 정수
* 정수 : int<br>
(위치, 점수 합, 반복 횟수를 표현하기 위해 사용됨<br>
이때 반복 횟수가 가장 커질 수 있는데 최대 $10,000$ 이므로 int면 충분)

<br>

## 전체 코드

```cpp
#include<stdio.h>

#define LEN 10
#define NODE_CNT 33
#define HORSE_CNT 4
#define MARGIN 1

#define START 0
#define END 32
#define NONE -1

#define FALSE 0
#define TRUE 1

typedef struct {
    int score;
    int red;
    int blue;
}Node;

Node Map[NODE_CNT + MARGIN];
int List[LEN + MARGIN];
int Horses[HORSE_CNT + MARGIN];
int MaxScore;

int Selected[LEN + MARGIN];

void setMap();
void DFS(const int cnt, const int score);

int main() {

    for (int i = 0; i < LEN; i++) {
        scanf("%d", &(List[i]));
    }

    setMap();
    DFS(0, 0);

    printf("%d", MaxScore);

    return 0;
}

void setMap() {

    for (int i = START; i < 20; i++) {
        Map[i].red = i + 1;   Map[i].score = i * 2;
    }
    Map[20].red = END;  Map[20].score = 40;

    Map[21].red = 22;   Map[21].score = 13;
    Map[22].red = 23;   Map[22].score = 16;

    Map[24].red = 25;   Map[24].score = 22;

    Map[26].red = 27;    Map[26].score = 28;
    Map[27].red = 28;   Map[27].score = 27;

    Map[23].red = 29;   Map[23].score = 19;
    Map[25].red = 29;   Map[25].score = 24;
    Map[28].red = 29;   Map[28].score = 26;

    Map[29].red = 30;   Map[29].score = 25;
    Map[30].red = 31;   Map[30].score = 30;
    Map[31].red = 20;   Map[31].score = 35;

    Map[END].red = NONE;    Map[END].score = 0;

    for (int i = START; i <= END; i++) {
        Map[i].blue = NONE;
    }
    Map[5].blue = 21;
    Map[10].blue = 24;
    Map[15].blue = 26;

}
int move(int now, int cnt) {
    cnt--;
    if (now == 5 || now == 10 || now == 15)
        now = Map[now].blue;
    else
        now = Map[now].red;
    while (cnt-- > 0 && now != END) {
        now = Map[now].red;
    }
    return now;
}
void DFS(const int cnt, const int score) {
    int endCnt = 0;
    for (int i = 0; i < HORSE_CNT; i++) {
        if (Horses[i] == END)
            endCnt++;
    }

    if (cnt >= 10 || endCnt == HORSE_CNT) {
        if (score > MaxScore)
            MaxScore = score;
    }
    else {
        for (int i = 0; i < HORSE_CNT; i++) {
            if (Horses[i] != END) {
                int next = move(Horses[i], List[cnt]);
                int j;
                for (j = 0; j < 4; j++) {
                    if (next != END && Horses[j] == next)
                        break;
                }
                if (j == 4) {
                    int tmp = Horses[i];
                    Horses[i] = next;
                    DFS(cnt + 1, score + Map[Horses[i]].score);
                    Horses[i] = tmp;
                }
            }
        }
    }
}
```

* 시간복잡도 $O(N)$
* 공간복잡도 $O(64) = O(1)$

<br>

[제출코드](https://www.acmicpc.net/source/49821564)

<br>

> 크기가 매우 작아서 크게 고민없이 풀수 있었던 문제<br>
> 블록을 내릴때 마지막 부분만 조심 <br>
> 축 대칭을 이용해서 구현을 줄이는게 나름 팁..?<br>
> 이동부분이 좀 지저분하게 구현된것 같은 느낌이... 나중에 해봐야겠다
